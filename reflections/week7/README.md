## Reflection on _Some Reflections on Designing Construction Kits for Kids_ by Michel Resnick and Brian Silverman. (2005)

Since I've recently wanted to build _construction_ kits for myself, I found this article very exciting. (And if these its could help other people to learn, it's even better). The authors give ten design advices to make these systems for kids but, really, these advices could apply to any design project.

The first tip is to design systems that will help people design by themself. This way of thinking about design definitely empower the user, which is what engaging object should do. They also suggest that the system should have a low floor and wide walls, meaning, easy and quick to access at first encounter while offering a lot of open possibilities to push a project further.

They also support the idea that good design should be as simple as possible. This means that one should make sure that every feature is there for a reason and, if not, remove it. This idea makes me think of the GUI that often people (me among others) add in order to increase the possibilities of a system through a simple interaction (knob, slider, number box). However, this GUI can make a task a lot more complex by confusing people in how to use that system.

One of the final advice concerns the way people should create in terms of what they would like to use themselves. I agree that one should not take the user for granted and consider them has wanted a lesser version of a tool than the designer. A system should be fascinating, exciting and fun for the designer in the first place if they hope for other people to engage with it!


## Reflections on _LEARNABLE PROGRAMMING_ by Bret Victor. (2012)

I will begin by disagreeing with the two points Bret Victor makes about learning. I think that, first of all, learning the basic logical tools of programming is definitely part of the training and differs from the analogy of the pen and the paper. (The equivalence would rather be the force you apply to the pen or the angle you draw with, these are _logical statements_ for how to use a pen). Second of all, I think that people are not **only** understanding things visually. I, myself, understand things mathematically and through hearing way better than visually, so learning from someone speaking about for loops and if-statements made total sense in my head when I learned about it. But people are different and some  would probably learn better if they see what they're doing. That's fine. But I believe that generalization is a weird perspective to have in education.

**labels**
I think that the idea of labeling parameters could definitely help someone learn to program in a smoother fashion. But one should be careful to not overload the interface with words, otherwise, it could become more confusing.

**flow**
The flow is another interesting concept brought up by Victor. A programming environment should show the intermediary steps between the code and the output. It could help a lot of people understanding what's behind a loop or a statement. The tool presented by Victor could definitely be integrated into environments such as Processing, but note that it already exists in some programming interface in the shape of a debugger.

"Are you seriously recalculating them in your head?", Victor asks. The skills of understanding and computing basic arithmetics in your head are pretty important in everyday life but also in the programming world. I don't think that this mathematical activity should be shamed because the computer is able to do it faster.

**creating by reacting.**
The autocomplete component that Victor is suggesting would definitely be a way to increase the speed of a programming task. He goes further and adds a toolbar of the shapes available in the software. To my experience, toolbars can be useful but they also can make a process way more tedious than actually writing/using the shortcuts for the operation you're trying to do. In Latex, for example, you can select an operation, let's say the integral operator, from a toolbar but it's a lot faster just to wright _\int_ than searching through all the toolboxes to find the symbol.

I enjoy that the programming environment becomes the external imagination of the user.

**creating by abstracting.**
I feel that this idea of creating by extracting wood elf people creating visual design very fast. I feel that in programming it's up in the case that people start with something specific like the example of a single house and then abstract it into a class. But the way Victor is doing that is super-efficient. And I don't think I've ever encountered an environment that supports this type of abstracting process.

The four language principles put forward by Victor are also illuminating. The idea of creating a language that holds metaphors seems definitely powerful in a learning environment. I am less sure about the _over_ readability that he seems to push forward. I personally believe that too much information can be cumbersome and can affect creativity (this is also what the artists interviewed in the following article are reacting to Dynamic Brushes).


## Reflection on _Extending Manual Drawing Practices with Artistic-Centric Programming Tools_ by Jennifer Jacobs. (2018)
I find the dual mode of Dynamic Brushes (DB) particularly suitable for creative practice. DB allows an artist to approach creation from, both, a procedural and a manual perspective. This enables to combine the best of both methods. I find the case study involving two artists with very different drawing/painting practices particularly interesting and representative of design struggles.

Both artists have similar but also different opinions concerning the interface. McGill finds annoying to switch from the programming interface to the drawing interface while Tritt embraces the division between both since it reflects his way to create brushes first and draw after.

How does a designer must deal with such a problem? In the light of the previous readings, adding more flexibility to adjust a software how one asks for is not necessarily the solution..
